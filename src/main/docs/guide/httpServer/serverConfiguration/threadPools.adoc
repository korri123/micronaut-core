The HTTP server is built on https://netty.io[Netty] which is designed as a non-blocking I/O toolkit in an event loop model.

The Netty worker event loop uses the "default" named event loop group. This can be configured through `micronaut.netty.event-loops.default`.

IMPORTANT: The event loop configuration under `micronaut.server.netty.worker` is only used if the `event-loop-group` is set to a name which doesn't correspond to any `micronaut.netty.event-loops` configuration. This behavior is deprecated and will be removed in a future version. Use `micronaut.netty.event-loops.*` for any event loop group configuration beyond setting the name through `event-loop-group`. This does not apply to the parent event loop configuration (`micronaut.server.netty.parent`).

include::{includedir}configurationProperties/io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration.Worker.adoc[]

TIP: The parent event loop can be configured with `micronaut.server.netty.parent` with the same configuration options.

The server can also be configured to use a different named worker event loop:

.Using a different event loop for the server
[source,yaml]
----
micronaut:
  server:
    netty:
      worker:
        event-loop-group: other
  netty:
    event-loops:
      other:
        num-threads: 10
----

NOTE: The default value for the number of threads is the value of the system property `io.netty.eventLoopThreads`, or if not specified, the available processors x 2.

See the following table for configuring event loops:

include::{includedir}configurationProperties/io.micronaut.http.netty.channel.DefaultEventLoopGroupConfiguration.adoc[]

==== Blocking Operations

When dealing with blocking operations, Micronaut shifts the blocking operations to an unbound, caching I/O thread pool by default. You can configure the I/O thread pool using the api:scheduling.executor.ExecutorConfiguration[] named `io`. For example:

.Configuring the Server I/O Thread Pool
[source,yaml]
----
micronaut:
  executors:
    io:
      type: fixed
      nThreads: 75
----

The above configuration creates a fixed thread pool with 75 threads.

In Micronaut methods are executed asynchronously by default. For example, methods that return reactive results execute asynchronously in Netty. Others execute in a dedicated I/O thread pool. Sometimes methods that are asynchronous need to execute in a blocking manner. The ann:core.annotation.Blocking[] facilitates this and is used to override default asynchronous execution, by routing calls to the IO executor. Examples might include subscribing to returned reactive types in a blocking manner, or for testing.  ann:core.annotation.Blocking[] is inherited so it can be used as a meta-annotation.

There are some places where the Micronaut framework uses ann:core.annotation.Blocking[] already.
|===
|Blocking Type|Description

|link:{micronautapi}http/client/BlockingHttpClient.html[BlockingHttpClient]
| Intended for testing, and provides blocking versions for a subset of api:http.client.HttpClient[] operations.
|link:{micronautapi}core/io/IOUtils.html[IOUtils]
| Reads the contents of a `BufferedReader` in a blocking manner, and returns that as a `String`.
|link:{micronautapi}context/env/BootstrapPropertySourceLocator.html[BootstrapPropertySourceLocator]
| Resolves either remote or local api:context.env.PropertySource[] instances for the current `Environment`.

|===

TIP: https://micronaut-projects.github.io/micronaut-data/latest/guide/[Micronaut Data] also utilizes `@Blocking` for some transaction operations, CRUD interceptors, and repositories.
